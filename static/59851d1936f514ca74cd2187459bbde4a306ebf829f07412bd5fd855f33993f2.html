<html><head><meta http-equiv=Content-Type content="text/html; charset=UTF-8"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/urlib/bin_8@1513039c5fdd700b9e79073f29111b91b40e74d0/79/f2/60/04/79f26004e48ea040cf486d00203b6f77178b94970bed611152397461000a57c0.css></head><body> <div style=position:absolute;left:50%;margin-left:-512px;top:0px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background01.jpg width=1024 height=768></div> <div style=position:absolute;left:322.00px;top:239.70px class=cls_002><span class=cls_002>图论⼊门</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:778px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background02.jpg width=1024 height=768></div> <div style=position:absolute;left:136.00px;top:106.55px class=cls_003><span class=cls_003>dfs</span><span class=cls_004>树</span><span class=cls_003>-tarjan</span><span class=cls_004>系列点双</span><span class=cls_003>，</span><span class=cls_004>边双</span><span class=cls_003>，</span><span class=cls_004>强联通</span></div> <div style=position:absolute;left:136.00px;top:174.43px class=cls_003><span class=cls_003>dfs</span><span class=cls_004>树与随机数</span></div> <div style=position:absolute;left:136.00px;top:242.31px class=cls_003><span class=cls_003>Dijkstra （heap)</span></div> <div style=position:absolute;left:136.00px;top:304.78px class=cls_003><span class=cls_003>Floyd</span> </div> <div style=position:absolute;left:136.00px;top:369.07px class=cls_004><span class=cls_004>⽆向图最小环</span> </div> <div style=position:absolute;left:136.00px;top:431.54px class=cls_003><span class=cls_003>bellman-ford/spfa</span></div> <div style=position:absolute;left:136.00px;top:495.83px class=cls_004><span class=cls_004>差分约束</span> </div> <div style=position:absolute;left:136.00px;top:558.30px class=cls_003><span class=cls_003>topological sorting</span></div> <div style=position:absolute;left:136.00px;top:622.59px class=cls_004><span class=cls_004>图的绝对中⼼</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:1556px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background03.jpg width=1024 height=768></div> <div style=position:absolute;left:422.64px;top:64.80px class=cls_005><span class=cls_005>dfs</span><span class=cls_006>树</span></div> <div style=position:absolute;left:142.00px;top:226.15px class=cls_007><span class=cls_007>对⼀副图进⾏</span><span class=cls_008>dfs</span><span class=cls_007>后按照</span><span class=cls_008>dfs</span><span class=cls_007>的顺序形成的⼀棵⽣成</span></div> <div style=position:absolute;left:142.00px;top:275.15px class=cls_007><span class=cls_007>树</span></div> <div style=position:absolute;left:142.00px;top:356.07px class=cls_007><span class=cls_007>图中的边可以分为树边与非树边</span></div> <div style=position:absolute;left:142.00px;top:436.99px class=cls_007><span class=cls_007>⽆向图中</span><span class=cls_008>，</span><span class=cls_007>非树边只会以返祖边</span><span class=cls_008>（</span><span class=cls_007>后向边</span><span class=cls_008>）</span><span class=cls_007>的形式</span></div> <div style=position:absolute;left:142.00px;top:485.99px class=cls_007><span class=cls_007>存在</span></div> <div style=position:absolute;left:142.00px;top:566.91px class=cls_007><span class=cls_007>有向图中</span><span class=cls_008>，</span><span class=cls_007>非树边还会以前向边与横叉边的形式存</span></div> <div style=position:absolute;left:142.00px;top:615.91px class=cls_007><span class=cls_007>在</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:2334px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background04.jpg width=1024 height=768></div> <div style=position:absolute;left:495.18px;top:25.71px class=cls_009><span class=cls_009>S</span></div> <div style=position:absolute;left:397.22px;top:257.68px class=cls_009><span class=cls_009>a</span></div> <div style=position:absolute;left:604.26px;top:283.56px class=cls_009><span class=cls_009>d</span></div> <div style=position:absolute;left:697.66px;top:430.20px class=cls_009><span class=cls_009>e</span></div> <div style=position:absolute;left:467.76px;top:473.17px class=cls_009><span class=cls_009>b</span></div> <div style=position:absolute;left:745.00px;top:541.76px class=cls_010><span class=cls_010>不存</span></div> <div style=position:absolute;left:727.00px;top:591.76px class=cls_010><span class=cls_010>在这种</span></div> <div style=position:absolute;left:759.84px;top:644.76px class=cls_010><span class=cls_010>边</span></div> <div style=position:absolute;left:465.16px;top:660.98px class=cls_009><span class=cls_009>c</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:3112px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background05.jpg width=1024 height=768></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:3890px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background06.jpg width=1024 height=768></div> <div style=position:absolute;left:432.00px;top:64.80px class=cls_006><span class=cls_006>割点</span></div> <div style=position:absolute;left:154.00px;top:360.36px class=cls_011><span class=cls_011>去掉割点后</span><span class=cls_012>，</span><span class=cls_011>图会不连通</span></div> <div style=position:absolute;left:154.00px;top:467.36px class=cls_011><span class=cls_011>树的非叶节点都是割点</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:4668px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background07.jpg width=1024 height=768></div> <div style=position:absolute;left:154.00px;top:183.36px class=cls_011><span class=cls_011>割点的两种情况</span> </div> <div style=position:absolute;left:154.00px;top:290.36px class=cls_012><span class=cls_012>1：</span><span class=cls_011>根节点在</span><span class=cls_012>dfs</span><span class=cls_011>树中有两个或以上的</span></div> <div style=position:absolute;left:154.00px;top:355.36px class=cls_011><span class=cls_011>⼉⼦</span><span class=cls_012>，</span><span class=cls_011>根节点为割点</span></div> <div style=position:absolute;left:154.00px;top:462.36px class=cls_012><span class=cls_012>2：</span><span class=cls_011>非根节点</span><span class=cls_012>u</span><span class=cls_011>⾄少有⼀个⼦树没有返</span></div> <div style=position:absolute;left:154.00px;top:527.36px class=cls_011><span class=cls_011>祖边可以跨过</span><span class=cls_012>u</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:5446px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background08.jpg width=1024 height=768></div> <div style=position:absolute;left:571.68px;top:137.20px class=cls_009><span class=cls_009>S</span></div> <div style=position:absolute;left:426.28px;top:309.17px class=cls_009><span class=cls_009>U</span></div> <div style=position:absolute;left:774.21px;top:307.41px class=cls_009><span class=cls_009>Z</span></div> <div style=position:absolute;left:316.02px;top:476.92px class=cls_009><span class=cls_009>X</span></div> <div style=position:absolute;left:576.38px;top:496.34px class=cls_009><span class=cls_009>Y</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:6224px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background09.jpg width=1024 height=768></div> <div style=position:absolute;left:432.00px;top:64.80px class=cls_006><span class=cls_006>割边</span></div> <div style=position:absolute;left:150.50px;top:226.67px class=cls_013><span class=cls_013>去掉割边后图就不连通</span><span class=cls_014>，</span><span class=cls_013>也称为桥</span></div> <div style=position:absolute;left:150.50px;top:325.74px class=cls_013><span class=cls_013>⼀条边是割边当且仅当⼦树内返祖边都</span></div> <div style=position:absolute;left:150.50px;top:385.74px class=cls_013><span class=cls_013>⽆法跨过这条边</span> </div> <div style=position:absolute;left:150.50px;top:484.80px class=cls_013><span class=cls_013>将所有的割边去掉后</span><span class=cls_014>，</span><span class=cls_013>整个图会分成若</span></div> <div style=position:absolute;left:150.50px;top:544.80px class=cls_013><span class=cls_013>⼲个双联通分量</span><span class=cls_014>（</span><span class=cls_013>双联通⼦图</span><span class=cls_014>），</span><span class=cls_013>每⼀</span></div> <div style=position:absolute;left:150.50px;top:604.80px class=cls_013><span class=cls_013>个联通块内去掉⼀条边还是连通</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:7002px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background10.jpg width=1024 height=768></div> <div style=position:absolute;left:152.00px;top:64.80px class=cls_006><span class=cls_006>点双与边双具体求法</span> </div> <div style=position:absolute;left:130.50px;top:224.33px class=cls_015><span class=cls_015>每个节点维护两个信息</span></div> <div style=position:absolute;left:130.50px;top:280.59px class=cls_016><span class=cls_016>1：</span><span class=cls_015>第⼀次访问到的时间戳</span><span class=cls_016>dfn</span></div> <div style=position:absolute;left:130.50px;top:336.85px class=cls_016><span class=cls_016>2：</span><span class=cls_015>当前节点以及⼦树内部通过返祖边最早能访问到的时间戳</span><span class=cls_016>low</span></div> <div style=position:absolute;left:130.50px;top:393.11px class=cls_015><span class=cls_015>如果</span><span class=cls_016>low[from] == dfn[from]</span><span class=cls_015>说明</span><span class=cls_016>from</span><span class=cls_015>上面的那条边就是割边</span></div> <div style=position:absolute;left:130.50px;top:449.37px class=cls_016><span class=cls_016>low[to] >= dfn[from]</span><span class=cls_015>说明</span><span class=cls_016>to</span><span class=cls_015>⼦树⽆法返回到</span><span class=cls_016>from</span><span class=cls_015>上面</span><span class=cls_016>，from</span><span class=cls_015>为割点</span></div> <div style=position:absolute;left:130.50px;top:505.63px class=cls_016><span class=cls_016>dfs</span><span class=cls_015>的时候用⼀个栈保存搜到的点</span><span class=cls_016>，</span><span class=cls_015>回溯的时候⼀旦发现</span><span class=cls_016>low[from] ==</span></div> <div style=position:absolute;left:130.50px;top:539.63px class=cls_016><span class=cls_016>dfn[from]</span><span class=cls_015>就将栈中</span><span class=cls_016>from</span><span class=cls_015>⼦树内的点都退出</span><span class=cls_016>，</span><span class=cls_015>并标记成同⼀个连通分量</span> </div> <div style=position:absolute;left:130.50px;top:595.89px class=cls_015><span class=cls_015>求边双也可以使用树上差分</span><span class=cls_016>，</span><span class=cls_015>每条返祖边覆盖⼀段路径</span><span class=cls_016>，</span><span class=cls_015>割边被返祖边覆</span> </div> <div style=position:absolute;left:130.50px;top:629.89px class=cls_015><span class=cls_015>盖的次数为</span><span class=cls_016>0</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:7780px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background11.jpg width=1024 height=768></div> <div style=position:absolute;left:541.18px;top:65.71px class=cls_009><span class=cls_009>S</span></div> <div style=position:absolute;left:56.50px;top:189.78px class=cls_010><span class=cls_010>失去信仰退栈</span> </div> <div style=position:absolute;left:447.34px;top:198.34px class=cls_009><span class=cls_009>A</span></div> <div style=position:absolute;left:654.68px;top:243.56px class=cls_009><span class=cls_009>I</span></div> <div style=position:absolute;left:97.86px;top:272.17px class=cls_009><span class=cls_009>low = dfn</span> </div> <div style=position:absolute;left:388.68px;top:279.67px class=cls_009><span class=cls_009>B</span></div> <div style=position:absolute;left:771.76px;top:369.31px class=cls_009><span class=cls_009>J</span></div> <div style=position:absolute;left:496.44px;top:390.34px class=cls_009><span class=cls_009>F</span></div> <div style=position:absolute;left:351.90px;top:418.57px class=cls_009><span class=cls_009>C</span></div> <div style=position:absolute;left:908.42px;top:449.81px class=cls_009><span class=cls_009>K</span></div> <div style=position:absolute;left:271.68px;top:497.00px class=cls_009><span class=cls_009>D</span></div> <div style=position:absolute;left:595.18px;top:502.96px class=cls_009><span class=cls_009>G</span></div> <div style=position:absolute;left:123.26px;top:612.77px class=cls_009><span class=cls_009>E</span></div> <div style=position:absolute;left:832.17px;top:610.84px class=cls_010><span class=cls_010>信仰坚定</span> </div> <div style=position:absolute;left:653.50px;top:659.15px class=cls_009><span class=cls_009>H</span></div> <div style=position:absolute;left:832.17px;top:660.84px class=cls_010><span class=cls_010>环环相扣</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:8558px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background12.jpg width=1024 height=768></div> <div style=position:absolute;left:392.00px;top:64.80px class=cls_006><span class=cls_006>强连通</span></div> <div style=position:absolute;left:142.00px;top:226.15px class=cls_007><span class=cls_007>强连通是针对有向图⽽⾔的</span></div> <div style=position:absolute;left:142.00px;top:307.07px class=cls_007><span class=cls_007>强连通分量</span><span class=cls_008>(Strong Connected components) </span><span class=cls_007>内部两两</span></div> <div style=position:absolute;left:142.00px;top:356.07px class=cls_007><span class=cls_007>之间都有⼀条通路</span><span class=cls_008>(s->t, t->s)</span></div> <div style=position:absolute;left:142.00px;top:436.99px class=cls_007><span class=cls_007>强连通分量</span><span class=cls_008>（</span><span class=cls_007>极⼤强连通⼦图</span><span class=cls_008>）</span><span class=cls_007>缩点之后会构成⼀</span></div> <div style=position:absolute;left:142.00px;top:485.99px class=cls_007><span class=cls_007>副有向⽆环图</span><span class=cls_008>（DAG）</span></div> <div style=position:absolute;left:142.00px;top:566.91px class=cls_007><span class=cls_007>四种边</span><span class=cls_008>：</span><span class=cls_007>树边</span><span class=cls_008>，</span><span class=cls_007>返祖边</span><span class=cls_008>（</span><span class=cls_007>后向边</span><span class=cls_008>），</span><span class=cls_007>前向边</span><span class=cls_008>，</span><span class=cls_007>横插</span></div> <div style=position:absolute;left:142.00px;top:615.91px class=cls_007><span class=cls_007>边</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:9336px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background13.jpg width=1024 height=768></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:10114px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background14.jpg width=1024 height=768></div> <div style=position:absolute;left:232.00px;top:64.80px class=cls_006><span class=cls_006>强连通分量求法</span> </div> <div style=position:absolute;left:132.50px;top:223.87px class=cls_017><span class=cls_017>基本类似于边双的求法</span><span class=cls_018>，</span><span class=cls_017>用⼀个栈保存搜到的点</span><span class=cls_018>，</span><span class=cls_017>更新</span><span class=cls_018>low</span><span class=cls_017>值的时</span></div> <div style=position:absolute;left:132.50px;top:260.87px class=cls_017><span class=cls_017>候</span><span class=cls_018>，</span><span class=cls_017>如果相邻的点已经访问过</span><span class=cls_018>，</span><span class=cls_017>这个点⼀定要在栈里面</span><span class=cls_018>，</span><span class=cls_017>不在栈里面</span></div> <div style=position:absolute;left:132.50px;top:297.87px class=cls_017><span class=cls_017>的已经访问过的点是已经与别的点构成了强连通分量的点</span><span class=cls_018>，</span><span class=cls_017>比如</span><span class=cls_018>H->K</span></div> <div style=position:absolute;left:132.50px;top:334.87px class=cls_017><span class=cls_017>的边</span></div> <div style=position:absolute;left:132.50px;top:395.81px class=cls_017><span class=cls_017>性质</span><span class=cls_018>1: </span><span class=cls_017>当</span><span class=cls_018>low[x]==dfn[x]</span><span class=cls_017>的时候执⾏出栈操作</span><span class=cls_018>，</span><span class=cls_017>将</span><span class=cls_018>x</span><span class=cls_017>能搜到的点都退</span></div> <div style=position:absolute;left:132.50px;top:432.81px class=cls_017><span class=cls_017>栈</span><span class=cls_018>，</span><span class=cls_017>他们构成了⼀个强连通分量</span><span class=cls_018>，</span><span class=cls_017>它们通过返祖边或者横叉边能直接</span></div> <div style=position:absolute;left:132.50px;top:469.81px class=cls_017><span class=cls_017>或者间接的到达</span><span class=cls_018>x</span></div> <div style=position:absolute;left:132.50px;top:530.75px class=cls_017><span class=cls_017>性质</span><span class=cls_018>2:</span><span class=cls_017>但是每个强连通分量都会在最⾼点求出来</span></div> <div style=position:absolute;left:132.50px;top:591.69px class=cls_017><span class=cls_017>性质</span><span class=cls_018>3:</span><span class=cls_017>如果</span><span class=cls_018>low</span><span class=cls_017>值是通过横叉边更新的</span><span class=cls_018>，</span><span class=cls_017>说明通过横叉边可以到</span><span class=cls_018>LCA</span><span class=cls_017>再</span></div> <div style=position:absolute;left:132.50px;top:628.69px class=cls_017><span class=cls_017>到自⼰</span><span class=cls_018>，</span><span class=cls_017>形成⼀个环</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:10892px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background15.jpg width=1024 height=768></div> <div style=position:absolute;left:540.18px;top:70.90px class=cls_009><span class=cls_009>S1_1</span></div> <div style=position:absolute;left:485.63px;top:204.90px class=cls_009><span class=cls_009>A5_1</span> </div> <div style=position:absolute;left:652.67px;top:242.68px class=cls_009><span class=cls_009>I2_2</span> </div> <div style=position:absolute;left:369.37px;top:296.53px class=cls_009><span class=cls_009>B6_1</span> </div> <div style=position:absolute;left:758.77px;top:382.28px class=cls_009><span class=cls_009>J3_2</span> </div> <div style=position:absolute;left:488.58px;top:390.40px class=cls_009><span class=cls_009>F7_5</span> </div> <div style=position:absolute;left:915.72px;top:398.68px class=cls_009><span class=cls_009>K4_2</span> </div> <div style=position:absolute;left:229.98px;top:420.71px class=cls_009><span class=cls_009>C_10_10</span> </div> <div style=position:absolute;left:592.14px;top:502.35px class=cls_009><span class=cls_009>G8_5</span> </div> <div style=position:absolute;left:252.34px;top:572.15px class=cls_009><span class=cls_009>D_11_10</span> </div> <div style=position:absolute;left:28.99px;top:624.40px class=cls_009><span class=cls_009>E_12_10</span> </div> <div style=position:absolute;left:624.64px;top:688.10px class=cls_009><span class=cls_009>H9_7</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:11670px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background16.jpg width=1024 height=768></div> <div style=position:absolute;left:262.64px;top:64.80px class=cls_005><span class=cls_005>dfs</span><span class=cls_006>树与随机数</span></div> <div style=position:absolute;left:154.00px;top:335.36px class=cls_011><span class=cls_011>给出⼀个⽆向图</span><span class=cls_012>，</span><span class=cls_011>每次询问删掉给定</span></div> <div style=position:absolute;left:154.00px;top:400.36px class=cls_011><span class=cls_011>的</span><span class=cls_012>k</span><span class=cls_011>条边后图是否连通</span></div> <div style=position:absolute;left:154.00px;top:497.97px class=cls_012><span class=cls_012>n&lt;=100000,m&lt;=500000,q&lt;=50000,k&lt;=15</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:12448px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background17.jpg width=1024 height=768></div> <div style=position:absolute;left:154.00px;top:129.36px class=cls_011><span class=cls_011>构造</span><span class=cls_012>dfs</span><span class=cls_011>树</span><span class=cls_012>，</span><span class=cls_011>非树边</span><span class=cls_012>rand</span><span class=cls_011>⼀个值</span></div> <div style=position:absolute;left:154.00px;top:236.36px class=cls_011><span class=cls_011>树边的值等于所有覆盖它的非树边的</span></div> <div style=position:absolute;left:154.00px;top:301.36px class=cls_011><span class=cls_011>值的</span><span class=cls_012>xor</span></div> <div style=position:absolute;left:154.00px;top:408.36px class=cls_011><span class=cls_011>问题等价于是否存在⼀个⼦集的</span><span class=cls_012>xor</span><span class=cls_011>和</span> </div> <div style=position:absolute;left:154.00px;top:473.36px class=cls_011><span class=cls_011>为</span><span class=cls_012>0</span></div> <div style=position:absolute;left:154.00px;top:580.36px class=cls_011><span class=cls_011>同样的思路可以用来求割边的数量</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:13226px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background18.jpg width=1024 height=768></div> <div style=position:absolute;left:380.48px;top:61.56px class=cls_005><span class=cls_005>Dijkstra</span> </div> <div style=position:absolute;left:153.50px;top:224.98px class=cls_019><span class=cls_019>类似于</span><span class=cls_020>prim，</span><span class=cls_019>将节点分成两类</span><span class=cls_020>，</span><span class=cls_019>已确</span></div> <div style=position:absolute;left:153.50px;top:287.98px class=cls_019><span class=cls_019>定最短距离节点与未确定点。每次从</span></div> <div style=position:absolute;left:153.50px;top:350.98px class=cls_019><span class=cls_019>未确定点集中选取距离值最小的⼀个</span></div> <div style=position:absolute;left:153.50px;top:413.98px class=cls_019><span class=cls_019>点加⼊到最短路点集中</span><span class=cls_020>，</span><span class=cls_019>因为这个点</span></div> <div style=position:absolute;left:153.50px;top:476.98px class=cls_019><span class=cls_019>的最短路径不可能再被更新了</span><span class=cls_020>，</span><span class=cls_019>然后</span></div> <div style=position:absolute;left:153.50px;top:539.98px class=cls_019><span class=cls_019>用这个点的最短路径去更新邻接点的</span></div> <div style=position:absolute;left:153.50px;top:602.98px class=cls_019><span class=cls_019>最短路径</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:14004px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background19.jpg width=1024 height=768></div> <div style=position:absolute;left:289.52px;top:61.56px class=cls_005><span class=cls_005>djikstra+heap</span></div> <div style=position:absolute;left:147.00px;top:224.99px class=cls_021><span class=cls_021>用⼀个堆维护距离的最小值</span><span class=cls_022>，</span><span class=cls_021>每次从堆中取</span> </div> <div style=position:absolute;left:147.00px;top:279.99px class=cls_021><span class=cls_021>出⼀个最小的值</span><span class=cls_022>，</span><span class=cls_021>如果这个值⼤于当前真实</span> </div> <div style=position:absolute;left:147.00px;top:334.99px class=cls_021><span class=cls_021>的距离</span><span class=cls_022>，</span><span class=cls_021>就不要</span><span class=cls_022>，</span><span class=cls_021>因为有可能被放⼊堆之</span></div> <div style=position:absolute;left:147.00px;top:389.99px class=cls_021><span class=cls_021>后</span><span class=cls_022>，</span><span class=cls_021>又被别的点更新了最短路</span><span class=cls_022>，</span><span class=cls_021>当确定是最</span></div> <div style=position:absolute;left:147.00px;top:444.99px class=cls_021><span class=cls_021>短路后</span><span class=cls_022>，</span><span class=cls_021>就拿这个点的最短路去更新相邻</span></div> <div style=position:absolute;left:147.00px;top:499.99px class=cls_021><span class=cls_021>点</span><span class=cls_022>，</span><span class=cls_021>把它们的距离值放⼊堆中</span><span class=cls_022>，</span><span class=cls_021>因此⼀个点</span></div> <div style=position:absolute;left:147.00px;top:554.99px class=cls_021><span class=cls_021>会⼊堆多次</span><span class=cls_022>，</span><span class=cls_021>⼊堆总次数为边的数量</span><span class=cls_022>，</span><span class=cls_021>复杂</span></div> <div style=position:absolute;left:147.00px;top:609.99px class=cls_021><span class=cls_021>度应该为</span><span class=cls_022>mlogm</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:14782px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background20.jpg width=1024 height=768></div> <div style=position:absolute;left:438.72px;top:61.56px class=cls_005><span class=cls_005>floyd</span> </div> <div style=position:absolute;left:140.50px;top:250.00px class=cls_023><span class=cls_023>经典的三个循环</span> </div> <div style=position:absolute;left:140.50px;top:327.66px class=cls_023><span class=cls_023>考虑某⼀条最短路的形成过程</span><span class=cls_024>，</span><span class=cls_023>当路径上的点被⼀个</span> </div> <div style=position:absolute;left:140.50px;top:374.66px class=cls_023><span class=cls_023>个考虑进来的时候</span><span class=cls_024>，</span><span class=cls_023>会形成⼀段段区间</span><span class=cls_024>，</span><span class=cls_023>每⼀段区间</span></div> <div style=position:absolute;left:140.50px;top:421.66px class=cls_023><span class=cls_023>内部的两两之间的最短路都已经求出</span><span class=cls_024>，</span><span class=cls_023>每加⼊⼀个点</span> </div> <div style=position:absolute;left:140.50px;top:468.66px class=cls_023><span class=cls_023>会连通两个相邻的区间。左区间到右区间的点之间的</span></div> <div style=position:absolute;left:140.50px;top:515.66px class=cls_023><span class=cls_023>最短路会在此时正式形成</span></div> <div style=position:absolute;left:140.50px;top:593.32px class=cls_023><span class=cls_023>所以外层的循环</span><span class=cls_024>random_shuffle</span><span class=cls_023>⼀下也不会影响正确性</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:15560px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background21.jpg width=1024 height=768></div> <div style=position:absolute;left:272.00px;top:64.80px class=cls_006><span class=cls_006>⽆向图最小环</span> </div> <div style=position:absolute;left:138.00px;top:248.08px class=cls_025><span class=cls_025>⼀个环可以拆成⼀条最短路加上两条相邻的边的形式</span></div> <div style=position:absolute;left:138.00px;top:320.64px class=cls_025><span class=cls_025>因此可以在用当前点</span><span class=cls_026>k</span><span class=cls_025>去更新最短路之前先把</span><span class=cls_026>i->k k->j</span><span class=cls_025>两条</span> </div> <div style=position:absolute;left:138.00px;top:364.64px class=cls_025><span class=cls_025>边当作环上的两条边去更新最小环</span></div> <div style=position:absolute;left:138.00px;top:437.20px class=cls_025><span class=cls_025>记录</span><span class=cls_026>pre[i][j] </span><span class=cls_025>表示</span><span class=cls_026>i</span><span class=cls_025>到</span><span class=cls_026>j</span><span class=cls_025>最短路上的第⼀个点</span></div> <div style=position:absolute;left:138.00px;top:509.76px class=cls_025><span class=cls_025>最小环上的点⽆论以什么顺序考虑进来</span><span class=cls_026>，</span><span class=cls_025>在考虑到还差⼀</span></div> <div style=position:absolute;left:138.00px;top:553.76px class=cls_025><span class=cls_025>个点</span><span class=cls_026>k</span><span class=cls_025>的时候</span><span class=cls_026>（</span><span class=cls_025>假设环上与</span><span class=cls_026>k</span><span class=cls_025>相邻的点为</span><span class=cls_026>a，b），</span><span class=cls_025>其他的点</span></div> <div style=position:absolute;left:138.00px;top:597.76px class=cls_025><span class=cls_025>肯定⽆法更新</span><span class=cls_026>ab</span><span class=cls_025>之间的最短路了</span><span class=cls_026>，</span><span class=cls_025>不然就会存在更小环</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:16338px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background22.jpg width=1024 height=768></div> <div style=position:absolute;left:218.16px;top:61.56px class=cls_005><span class=cls_005>bellman-ford/spfa</span></div> <div style=position:absolute;left:144.50px;top:246.07px class=cls_027><span class=cls_027>⼀个节点的最短距离值最多被更新</span><span class=cls_028>n-1</span><span class=cls_027>次</span><span class=cls_028>，</span><span class=cls_027>所以</span></div> <div style=position:absolute;left:144.50px;top:298.07px class=cls_027><span class=cls_027>每⼀轮都枚举所有边去更新最短路</span><span class=cls_028>dis[i]+w[i][j]</span></div> <div style=position:absolute;left:144.50px;top:350.07px class=cls_028><span class=cls_028>-> dis[j],n-1</span><span class=cls_027>轮之后所有的点的最短路都能更新完</span></div> <div style=position:absolute;left:144.50px;top:402.07px class=cls_027><span class=cls_027>毕</span><span class=cls_028>，</span><span class=cls_027>如果第</span><span class=cls_028>n</span><span class=cls_027>轮还能继续更新</span><span class=cls_028>，</span><span class=cls_027>说明存在负环。</span></div> <div style=position:absolute;left:144.50px;top:488.09px class=cls_028><span class=cls_028>spfa</span><span class=cls_027>是</span><span class=cls_028>bellman-ford</span><span class=cls_027>的队列优化</span><span class=cls_028>，</span><span class=cls_027>每次将刚刚被</span></div> <div style=position:absolute;left:144.50px;top:540.09px class=cls_027><span class=cls_027>更新的点放进队列</span><span class=cls_028>，</span><span class=cls_027>优先去更新别⼈</span><span class=cls_028>，</span><span class=cls_027>知道队</span></div> <div style=position:absolute;left:144.50px;top:592.09px class=cls_027><span class=cls_027>列中元素为空为⽌。</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:17116px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background23.jpg width=1024 height=768></div> <div style=position:absolute;left:352.00px;top:64.80px class=cls_006><span class=cls_006>差分约束</span></div> <div style=position:absolute;left:153.00px;top:218.09px class=cls_029><span class=cls_029>B-A&lt;=c</span> </div> <div style=position:absolute;left:153.00px;top:308.25px class=cls_029><span class=cls_029>C-B&lt;=a</span> </div> <div style=position:absolute;left:153.00px;top:398.41px class=cls_029><span class=cls_029>C-A&lt;=b</span> </div> <div style=position:absolute;left:153.00px;top:497.07px class=cls_030><span class=cls_030>求</span><span class=cls_029>C-A</span><span class=cls_030>的最⼤值</span></div> <div style=position:absolute;left:153.00px;top:601.23px class=cls_030><span class=cls_030>答案为</span><span class=cls_029> min(a+c, b)</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:17894px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background24.jpg width=1024 height=768></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:18672px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background25.jpg width=1024 height=768></div> <div style=position:absolute;left:352.00px;top:64.80px class=cls_006><span class=cls_006>拓扑排序</span></div> <div style=position:absolute;left:154.00px;top:349.36px class=cls_011><span class=cls_011>不断的从⼊度为零的点开始</span><span class=cls_012>bfs，</span><span class=cls_011>搜到</span> </div> <div style=position:absolute;left:154.00px;top:414.36px class=cls_011><span class=cls_011>的点的度数减</span><span class=cls_012>1，</span><span class=cls_011>如果</span><span class=cls_012>bfs</span><span class=cls_011>结束后有的</span></div> <div style=position:absolute;left:154.00px;top:479.36px class=cls_011><span class=cls_011>点度数不为</span><span class=cls_012>0，</span><span class=cls_011>说明有环</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:19450px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background26.jpg width=1024 height=768></div> <div style=position:absolute;left:152.00px;top:64.80px class=cls_006><span class=cls_006>字典序最小的最短路</span> </div> <div style=position:absolute;left:154.00px;top:381.36px class=cls_011><span class=cls_011>建好最短路图之后直接从起点开始选</span></div> <div style=position:absolute;left:154.00px;top:446.36px class=cls_011><span class=cls_011>择编号小的</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:20228px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background27.jpg width=1024 height=768></div> <div style=position:absolute;left:272.00px;top:64.80px class=cls_006><span class=cls_006>图的绝对中⼼</span> </div> <div style=position:absolute;left:154.00px;top:349.36px class=cls_011><span class=cls_011>这个中⼼点可以存在与某⼀条边上</span><span class=cls_012>，</span></div> <div style=position:absolute;left:154.00px;top:414.36px class=cls_011><span class=cls_011>这个点到所有点的最短距离的最⼤值</span></div> <div style=position:absolute;left:154.00px;top:479.36px class=cls_011><span class=cls_011>最小</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:21006px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background28.jpg width=1024 height=768></div> <div style=position:absolute;left:154.00px;top:236.36px class=cls_011><span class=cls_011>绝对中⼼到所有点的最短距离的最⼤</span></div> <div style=position:absolute;left:154.00px;top:301.36px class=cls_011><span class=cls_011>值肯定会有两个</span><span class=cls_012>，</span><span class=cls_011>⽽且这两个最短距</span></div> <div style=position:absolute;left:154.00px;top:366.36px class=cls_011><span class=cls_011>离位于某条边的两端</span> </div> <div style=position:absolute;left:154.00px;top:473.36px class=cls_011><span class=cls_011>反证法</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:21784px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background29.jpg width=1024 height=768></div> <div style=position:absolute;left:154.00px;top:192.36px class=cls_011><span class=cls_011>枚举每⼀条边</span><span class=cls_012>u-v，</span><span class=cls_011>假设中⼼在这条边</span> </div> <div style=position:absolute;left:154.00px;top:257.36px class=cls_011><span class=cls_011>上</span><span class=cls_012>，</span><span class=cls_011>那么中⼼到某个点</span><span class=cls_012>s</span><span class=cls_011>的距离可以表</span></div> <div style=position:absolute;left:154.00px;top:322.36px class=cls_011><span class=cls_011>示为</span><span class=cls_012>min(d[u][s] + x, d[v][s]+L-x),</span><span class=cls_011>数形结</span></div> <div style=position:absolute;left:154.00px;top:387.36px class=cls_011><span class=cls_011>合⼀下发现这个是⼀条折线</span><span class=cls_012>，</span><span class=cls_011>每⼀条</span></div> <div style=position:absolute;left:154.00px;top:452.36px class=cls_011><span class=cls_011>边的折线取</span><span class=cls_012>max</span><span class=cls_011>构成了⼀个总的折</span></div> <div style=position:absolute;left:154.00px;top:517.36px class=cls_011><span class=cls_011>线</span><span class=cls_012>，</span><span class=cls_011>折线的最低点就是答案</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:22562px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background30.jpg width=1024 height=768></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:23340px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background31.jpg width=1024 height=768></div> <div style=position:absolute;left:312.00px;top:64.80px class=cls_006><span class=cls_006>最短路径树</span> </div> <div style=position:absolute;left:154.00px;top:381.36px class=cls_011><span class=cls_011>每个点记录⼀个最短路径所在的前驱</span></div> <div style=position:absolute;left:154.00px;top:446.36px class=cls_011><span class=cls_011>节点</span><span class=cls_012>，</span><span class=cls_011>形成的⼀棵树</span></div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:24118px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background32.jpg width=1024 height=768></div> <div style=position:absolute;left:136.40px;top:64.80px class=cls_006><span class=cls_006>最小直径⽣成树</span><span class=cls_005>MDST</span></div> <div style=position:absolute;left:148.50px;top:227.14px class=cls_031><span class=cls_031>求⼀棵⽣成树</span><span class=cls_032>，</span><span class=cls_031>树上最远的两个点距离最</span> </div> <div style=position:absolute;left:148.50px;top:284.14px class=cls_031><span class=cls_031>小</span></div> <div style=position:absolute;left:148.50px;top:378.52px class=cls_031><span class=cls_031>先求好绝对中⼼</span><span class=cls_032>（</span><span class=cls_031>所在的边上的两个端点</span><span class=cls_032>u-</span></div> <div style=position:absolute;left:148.50px;top:435.52px class=cls_032><span class=cls_032>v），</span><span class=cls_031>然后从绝对中⼼出发</span><span class=cls_032>，</span><span class=cls_031>位了保证这条</span></div> <div style=position:absolute;left:148.50px;top:492.52px class=cls_031><span class=cls_031>边⼀定在⽣成树上</span><span class=cls_032>，</span><span class=cls_031>⼀开始应该设设</span><span class=cls_032>d[u],</span></div> <div style=position:absolute;left:148.50px;top:549.52px class=cls_032><span class=cls_032>d[v]</span><span class=cls_031>为真实的值</span><span class=cls_032>（double），</span><span class=cls_031>然后搜出⼀颗</span> </div> <div style=position:absolute;left:148.50px;top:606.52px class=cls_031><span class=cls_031>最短路径树就是答案</span> </div> </div> <div style=position:absolute;left:50%;margin-left:-512px;top:24896px;width:1024px;height:768px;border-style:outset;overflow:hidden> <div style=position:absolute;left:0px;top:0px> <img src=https://cdn.jsdelivr.net/gh/PetrichorA/page-5dfbf3ed@0.0.0/background33.jpg width=1024 height=768></div> </div></body></html>